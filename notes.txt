in the middle of refactoring CursorCache to use arrays or maps, store cursor
using a symbol, children directly


requirements:
- data must be eventually consistent between peers
- messages may be delivered out of order
- messages may be lost or delivered multiple times


When a peer shares a document
- the peer sends a 'create' message to server with a requested room name
- if the name is in use, the server responds with 'rejected'
- otherwise the server creates the room, responds with 'created' and the peer's
  id in the room


When a peer requests an existing document
- the peer sends a 'join' message to the server with the room name
- if the room does not exist, the server responds with 'rejected'
- otherwise, the server sends a 'joined' message with the peer's id in the room
- the server sends 'request offer' messages to each exiting peer in the room
- the existing create offers and send 'offer' messages to the server w/ sdps
- the server forwards the 'offer' messages to the connecting peer
- the connecting peer creates answers and sends 'answer' messages to the server
  along with sds
- the server forwards the 'answer' messages to the existing peers
- the connecting and existing peers receive ice candidates, send 'candidate'
  messages to the server along with their candidates
- the server forwards the candidate messages to peers allowing connections to be
  formed
- the connecting peer sends a 'request document' message to the first existing
  peer it forms a connection to
- the peer responds with a 'document' message the current document and clock
- the peer sends 'request changes' with the document clock to each other peer,
  requesting any changes they have made after the clock
- the existing peers respond send any changes they have made after the clock,
  and begin sending new changes the connecting peer


When a user makes a change to the document
- the user increments its vector clock
- the user makes the change locally, and adds it along w/ the updated clock to a
  list of recent changes
- the user sends the path, updated value, and updated clock to each peer


When a user recieves a message indicating a change to the document
- the user compares the incoming clock to its clock
- if the incoming clock is later, the user applies the change, appends it to its
  list of recent changes, and updates its clock
- if the incoming clock is earlier, the user looks in its list of changes until
  it finds the immediately preceding change.
- if no paths in the conflicting changes overlap, the user applies the change
  and inserts it in place to the list of recent changes
- if paths do overlap, the user rewinds state to the immediately preceding
  change, then applies all remaining changes in order.
- conflicts are resolved in favor of the author with lowest id
- if the incoming clock indicates a missed message from one peer, the user sets
  a timeout after which it will send a 'request sync' message with the missing
  author id and clock ticks
- the user invalidates any existing timeouts that the incoming message makes
  redundant


Ultrawave.create room, data, (root) ->

Ultrawave.join room, (root) ->
